
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Think in Recursion book by F. Jin, covers recursion problems such as sum, fibonacci, climb stair, bucket fill, permutation and etc.">
    <meta name="keywords" content="Recursion, Javascript, Haskell, Fibonacci, Permutation">
    <meta name="author" content="Fang Jin">
    <link rel="icon" type="image/x-icon" href="/book/favicon/favicon.ico">
    <link rel="manifest" href="/book/favicon/manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,400;0,700;1,300;1,400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&display=swap" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400&display=swap" rel="stylesheet" type="text/css">
    <link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet">
    <link rel="stylesheet" href="../bundle.css">
    <title>Call stack</title>
  </head>
  <body id="top">
    <nav>
  <div class="navbar">
    <div class="container nav-container">
      <input class="checkbox" type="checkbox" name="" id="">
      <div class="hamburger-lines">
        <span class="line line1"></span>
        <span class="line line2"></span>
        <span class="line line3"></span>
      </div>
      <div class="logo">
        <p><a href="/book/">Think in Recursion</a></p>
      </div>
      <div class="menu-items"><li>
          <a href="/book/sum/">1. Sum</a>
        </li><li>
          <a href="/book/callstack/">2. Call stack</a>
        </li><li>
          <a href="/book/factorial/">3. Factorial</a>
        </li><li>
          <a href="/book/fibonacci/">4. Fibonacci</a>
        </li><li>
          <a href="/book/stairs/">5. Stairs</a>
        </li><li>
          <a href="/book/paint/">6. Paint</a>
        </li><li>
          <a href="/book/permute/">7. Permute</a>
        </li><li>
          <a href="/book/queens/">8. Queens</a>
        </li><li>
          <a href="/book/path/">9. Path I</a>
        </li><li>
          <a href="/book/path2/">10. Path II</a>
        </li></div>
    </div>
  </div>
</nav>

    <main><p class="chapter-number">2</p>
<h1>Call stack</h1>
<p>In the previous, we have come up a recursive algorithm for adding numbers. I hope you don't feel redundant to apply recursion to a problem this trivial. But I'll assure you <code>sum</code> is such a fundamental problem in the course of studying recursion that it can only help you understand the recursion better. Before we move on to solve other problems, this chapter will turn to a topic about a potential bug in our code.</p>
<p>I'm sure you have tried to run <code>sum</code> for different <code>n</code>. Have you tried <code>sum(10000)</code>?</p>
<pre><code>Maximum call stack size exceeded VM327:2
 sum @ VM327:2
 sum @ VM327:3
 sum @ VM327:3
 sum @ VM327:3
 .
 .
 .
</code></pre>
<p>If you have tried, I have to admit that I lied, <code>sum</code> code actually doesn't work for that <code>n</code> or above, because most likely you ended up a message like above.</p>
<p>How so? What's the message about? Why it works for <code>sum(9000)</code> but not <code>sum(10000)</code>? What's so special about <code>10000</code>? Lots of questions.</p>
<p>Drilling down the message, it shows that our code calls <code>sum</code>, and then calls <code>sum</code> and then calls <code>sum</code> ... And then, there's no then. So <code>9000</code> times didn't break it, but <code>10000</code> times broke it. Hmm?!</p>
<p>Pretty much that is what happened. Only a minor detail, it's less about the exact number <code>10000</code>, but more about something called the &quot;Maximum call stack size&quot; from your running environment.</p>
<blockquote>
<p>Everyone's running environment could be different. We can differ by operation systems, nodejs runtime versions and etc.</p>
</blockquote>
<h2>What is call stack?</h2>
<p class="caption"><img src="../images/stack.png" alt="Call stack"><br>
Fig. Call stack</p>
<p>The call stack is a container for function calls. When a function is called, it'll be added to this list. This is for the computer to keep track of how many calls currently are running in your language environment.</p>
<p>When a function is invoked, the call stack needs to allocate memory for the function instance, to store local variables as well as to remember where it returns to when it finishes. Thus you can see there's an overhead of calling a function.</p>
<p>Functions call and return. Transparent to us, the call stack runs behind the scene most of time. But sometimes when you write a bug, such as calling functions in a faster rate than finishing them, the computer has to allocate more and more memory, until the point it can't allocate anymore. This is when the &quot;Maximum call stack size&quot; is reached. The size here refers to the memory size instead of instances count.</p>
<p>Back to our <code>sum</code> case, it calls <code>sum(n)</code> first, and then <code>n-1</code> till <code>0</code>, each time when it calls, it does not get chance to close the previous call because the previous call is waiting the new call to finish first. Thus the active function instances keep incrementing until it reaches somewhere around <code>10000</code>, it exceeds the max memory that the call stack can allocate.</p>
<p>Bummer!</p>
<p>So how do we get around of this issue so that we can run <code>sum(10000)</code>? There are couple of options.</p>
<h2>Live with it</h2>
<p>The option sounds like not an option.</p>
<blockquote>
<p>Most of us live with the call stack peacefully.</p>
</blockquote>
<p>10000 calls is a lot of calls. This number doesn't mean we only can call <code>10000</code> functions in our program. This number stands for that, you can't have <code>10000</code> active functions running at the same time. For instance, you can call some functions, finish some functions and then call another bunch of functions. This turns out to be the most calling pattern.</p>
<p>If you really really want to make more calls, there's still ways. Your language sometimes open a way for us to change this limit temporarily. For JavaScript, we can play with the stack-size setting.</p>
<p>Save <code>sum</code> function into <code>sum.js</code> file.</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Now we can run it in the terminal.</p>
<pre><code>&gt; node --stack-size=900 sum.js
Maximum call stack size exceeded

&gt; node --stack-size=1000 sum.js
50005000
</code></pre>
<p>Using the <code>stack-size</code> flag, we can get it working. It's not convenient, not to mention it takes some trial-and-error to find out the right stack size for your problem.</p>
<p>Luckily, other than playing with the environnement setting, we have other ways addressing this issue.</p>
<h2>Iterative setup</h2>
<p>We have been using recursive function calls. But we can also implement the recursion with the iterative setup. Or sometimes when we finish a recursive, we convert it by eliminating recursive calls.</p>
<p>For example, we could write our <code>sum</code> algorithm in an iterative way.</p>
<pre><code>function sum(n)
{
  let res = 0;
  for (let i = 0; i &lt;= n; i++) {
    res = res + i
  }
  return res;
}
</code></pre>
<p>I know what you’re gonna say. It’s basically the classical <code>for</code> approach. Well, I admit it, but for this simple problem, it just happens that the converted version is identical to the iterative version. This isn't an coincidence that they look the same. For this problem, there's only one way to go through the array iteratively.</p>
<p>Not all recursion can be converted this easy. Some are easy, and some can be really tricky to write. And I can assure you that the converted version can look a bit different to the iterative style. Because the conversion also try hard to keep the recursive signature of the problem. We only want to get around the stack limit issue, but we still want to use the recursion approach.</p>
<p>With the converted version, we can now call it with larger number without worrying about running into error.</p>
<pre><code>&gt; sum(10000)
50005000

&gt; sum(100000)
5000050000

&gt; sum(1000000)
500000500000

&gt; sum(10000000)
50000005000000

&gt; sum(100000000)
5000000050000000

&gt; sum(1000000000)
50000000006710900
</code></pre>
<h2>Haskell language</h2>
<p>There're other options. If your language doesn't work, maybe try other languages.</p>
<p>Recursion normally isn’t a language feature, it’s more like a by-product of a language. It doesn't get enough attention by the main stream languages usually. However, there exits language that does build on top of the recursion mindset, such as Haskell.</p>
<blockquote>
<p>Haskell is an advanced, purely functional programming language.</p>
</blockquote>
<p>It’s hard to miss this language if you are fan of recursion, because Haskell fully appreciates the power of recursion at its core. Using it to write recursion is like writing down our thoughts. Say we write the <code>sum</code> in recursion in Haskell.</p>
<pre><code>sum 0 = 0
sum n = sum (n-1) + n
</code></pre>
<p>The syntax of Haskell function can be strange to some of us initially since its argument is not wrapped within a bracket. Instead it uses a space to separate the function name and its argument.</p>
<p>Our Haskell version has two lines, and looks quite similar to the specification than the code. Yeah, but that's the code.</p>
<p>Run it and let's see the result.</p>
<pre><code>&gt; sum 10000
50005000

&gt; sum 100000
5000050000

&gt; sum 1000000
500000500000

&gt; sum 10000000
50000005000000

&gt; sum 100000000
5000000050000000

&gt; sum 1000000000
500000000500000000
</code></pre>
<p>The Haskell version works with large recursion levels out of the box. It only has a max call stack size, but its size is set to be relatively high by default.</p>
<p>You might be like, if Haskell is that easy, why don’t we just start with Haskell, well, as I mentioned, writing in Haskell is like writing your thoughts, and sometimes it’s difficult to write down your thoughts, it takes some skill and practice to get there.</p>
<p>This book isn't about teaching you how to write down your thought, maybe it is, but we’ll focus on the recursion, so we use Haskell version as a reference to confirm our design and check results, more to use Haskell as a helper. It's good to be sure we are right!</p>
</main>
    <footer>
  <div>
    <p>
      <a href="https://www.freepik.com/free-vector/brain-icons-flat_4663387.htm#query=brain&position=15&from_view=search&track=sph&uuid=c43d2599-7e99-42e3-9d6b-4cc4b554107c?log-in=google">
        Image by macrovector_official</a>
      on Freepik
    </p>
    <p>
      © Think in Recursion 2023 - 2024
      <a href="https://www.linkedin.com/in/windmaomao/">F. Jin</a>
    </p>
  </div>
  <p>
    <a href="#top">Back to top</a>
  </p>
</footer>
 <script type="module" async="">import mermaid from "https://unpkg.com/mermaid@10/dist/mermaid.esm.min.mjs";document.addEventListener('DOMContentLoaded', mermaid.initialize({"loadOnSave":true}));</script>
  </body>
</html>
