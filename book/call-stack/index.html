
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Think in Recursion book by F. Jin, covers recursion problems such as sum, fibonacci, climb stair, bucket fill, permutation and etc.">
    <meta name="keywords" content="Recursion, Javascript, Haskell, Fibonacci, Permutation">
    <meta name="author" content="Fang Jin">
    <link rel="icon" type="image/x-icon" href="/book/favicon/favicon.ico">
    <link rel="manifest" href="/book/favicon/manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,400;0,700;1,300;1,400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&display=swap" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400&display=swap" rel="stylesheet" type="text/css">
    <link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet">
    <link rel="stylesheet" href="../bundle.css">
    <title>Call stack</title>
  </head>
  <body id="top">
    <nav>
  <div class="navbar">
    <div class="container nav-container">
      <input class="checkbox" type="checkbox" name="" id="">
      <div class="hamburger-lines">
        <span class="line line1"></span>
        <span class="line line2"></span>
        <span class="line line3"></span>
      </div>
      <div class="logo">
        <p><a href="/book/">Think in Recursion</a></p>
      </div>
      <div class="menu-items"><li>
          <a href="/book/sum-numbers/">1. Sum</a>
        </li><li>
          <a href="/book/call-stack/">2. Call stack</a>
        </li><li>
          <a href="/book/factorial/">3. Factorial</a>
        </li><li>
          <a href="/book/fib-sequence/">4. Fibonacci</a>
        </li><li>
          <a href="/book/climb-stairs/">5. Climbing stairs</a>
        </li><li>
          <a href="/book/bucket-fill/">6. Flood fill</a>
        </li><li>
          <a href="/book/permutation/">7. Permutation</a>
        </li></div>
    </div>
  </div>
</nav>

    <main><p class="chapter-number">2</p>
<h1>Call stack</h1>
<p>In the previous, we have come up a recursive algorithm for <code>sum</code>. I hope you don't get annoyed by using an recursion for a basic problem. But I'll assure you <code>sum</code> is such a basic and fundamental problem in studying recursion. Before we move on to solve other problems, this chapter will turn to talk about a bug in <code>sum</code>.</p>
<p>I'm sure you have tried to run <code>sum</code> couple of times with different <code>n</code>. Have you tried <code>sum(10000)</code>?</p>
<pre><code>Maximum call stack size exceeded VM327:2
 sum @ VM327:2
 sum @ VM327:3
 sum @ VM327:3
 sum @ VM327:3
 .
 .
 .
</code></pre>
<p>If you have tried, I have to admit that I lied, <code>sum</code> code actually doesn't work for that <code>n</code> or above, because we'll see a message like above.</p>
<p>How so? What's that message about? Why it works for <code>sum(9000)</code> but not <code>sum(10000)</code>? What's special about <code>10000</code>? Wow, I know you might have lots of questions.</p>
<p>Drilling down the message, it shows that our code calls <code>sum</code>, and then calls <code>sum</code> and then calls <code>sum</code> ... And then it's broken. So <code>9000</code> times doesn't break it, but <code>10000</code> times break it. Hmm?!</p>
<p>Pretty much so. Only a small correction, it's less about this exact number <code>10000</code>, but more about something called the &quot;Maximum call stack size&quot;.</p>
<h2>What is call stack?</h2>
<p class="caption"><img src="../images/stack.png" alt="Call stack"><br>
Fig. Call stack</p>
<p>The call stack is a container for function calls. When a function is called, it'll be added to this list. This is for the computer to keep track of how many calls currently are running.</p>
<p>When a function is invoked, the call stack needs to allocate memory for the function, such as storing the function's local variables. The call stack also need to remember where the function returns to after it finishes. Thus you can see there's an overhead of running a function inside computer.</p>
<p>Functions call and return. The call stack runs behind the scene smoothly and transparently. However, in one extreme edge case, or you can say a buggy case, if functions are called in a faster rate than finishing rate, the computer starts to allocate more and more memory, until the point it can't allocate anymore. This is when we hit so called &quot;Maximum call stack size&quot;.</p>
<p>Now it's making perfect sense that why we can get this error. In a recursion setup, our scheme is about calling a call by itself constantly. We keep adding calls that can't finish before issuing more calls, it's matter of time we'll exceed the memory limit. Therefore, all recursion has a possibility to hit this limit.</p>
<p>Back to our <code>sum</code> case, it just happens that when the active function instances count approaches <code>10000</code>, it exceeds the max memory that the call stack can allocate.</p>
<p>Bummer!</p>
<p>In order to run code with more recursion level, we need to find a way to walk around this problem. There are couple of options.</p>
<h2>Live with it</h2>
<p>The option sounds not an option.</p>
<p>10000 calls is a lot of active function calls. Luckily, lots of problems can be solved within this limit.</p>
<p>If you really really want to make more calls, there's still ways. Your language running environment provides a way for us to change this limit temporarily. For JavaScript, we can play with the stack-size setting.</p>
<pre><code>&gt; node --stack-size=900 sum.js
Maximum stack size is 12763 calls
</code></pre>
<p>It’s not too bad temporarily, but it can be inconvenient. Also the maximum call stack size is there for a reason; it tries to protect you from the stack overflow.</p>
<p>Other than living with it, we have other ways addressing this issue.</p>
<h2>Iterative setup</h2>
<p>Luckily there’s different ways of implementing the recursion. We have been using recursive function calls. But we can also implement the recursion with the iterative setup. Or sometimes when we finish a recursive, we convert it using an iterative setup.</p>
<p>For example, we could write our <code>sum</code> algorithm in an iterative setup.</p>
<pre><code>function sum(n)
{
  let res = 0;
  for (let i = 0; i &lt;= n; i++) {
    res = res + i
  }
  return res;
}
</code></pre>
<p>I know what you’re gonna say. It’s basically the classical <code>for</code> approach. Well, I admit it, but for this simple problem, it just happens that the converted version is identical to the iterative version. I can call this a coincidence, however it probably isn't an coincidence that both setups point to the same version. In the end, they suppose to do the same thing.</p>
<p>After the conversion, maybe all recursion carries a bit assemblence to the iterative approach. But the matter of fact is that, the recursion nature is kept during the conversion, whereas the iterative approach has no recursion built in mind. And interestingly enough, not all recursion can be converted very easily. Some are easy, and some can be really tricky to write. Therefore I assure you, the iterative approach and the iterative setup for the recursion are two different things.</p>
<p>With the converted version, we can now call it with larger number without worrying about running into error.</p>
<pre><code>&gt; sum(10000)
50005000
&gt; sum(100000)
5000050000
&gt; sum(1000000)
500000500000
&gt; sum(10000000)
50000005000000
&gt; sum(100000000)
5000000050000000
&gt; sum(1000000000)
50000000006710900
</code></pre>
<h2>Haskell language</h2>
<p>In terms of running recursion without hitting the limit, here comes the third option.</p>
<p>Recursion normally isn’t a language feature, it’s more like a by-product of a language. It doesn't get enough attention by the main stream languages usually. However, there exits language that does build on top of the recursion, such as Haskell - an advanced, purely functional programming language.</p>
<p>It’s hard to miss this language if you are fan of recursion, because Haskell fully appreciates the power of recursion at its core. Using it to write recursion is like writing down our thoughts. Say we write the sum in recursion in Haskell.</p>
<pre><code>sum 0 = 0
sum n = sum (n-1) + n
</code></pre>
<p>The syntax of Haskell function is slightly different, it calls the function without the bracket, instead it uses a space to separate the function name and its argument. Our Haskell version for sum has two lines, and looks quite similar to our documentation of the recursion :) Yeah, that's the code.</p>
<p>Run it and let's see the result.</p>
<pre><code>&gt; sum 10000
50005000
&gt; sum 100000
5000050000
&gt; sum 1000000
500000500000
&gt; sum 10000000
50000005000000
&gt; sum 100000000
5000000050000000
&gt; sum 1000000000
500000000500000000
</code></pre>
<p>The Haskell version works with large recursion levels out of the box. And it takes only a few seconds to run. This shows the power of Haskell as well as its dedication to the recursion.</p>
<blockquote>
<p>Have you noticed the sum carries a pattern by magnitude of 10? like 5050, 500500, 50005000, interesting.</p>
</blockquote>
<p>You might be like, if Haskell is that easy, why don’t we just start with Haskell, well, as I mentioned, writing in Haskell is like writing your thoughts, and sometimes it’s difficult to write down your thoughts, it takes some skill and practice. We are not teaching this skill in this book, instead we’ll use Haskell version as a reference to confirm our design and check results, more to use Haskell as a helper.</p>
<blockquote>
<p>Haskell also comes with a call stack limit. The reason why we don't hit it in this case is mainly because Haskell does a tail call optimiasation.</p>
</blockquote>
</main>
    <footer>
  <div>
    <p>
      <a href="https://www.freepik.com/free-vector/brain-icons-flat_4663387.htm#query=brain&position=15&from_view=search&track=sph&uuid=c43d2599-7e99-42e3-9d6b-4cc4b554107c?log-in=google">
        Image by macrovector_official</a>
      on Freepik
    </p>
    <p>
      © Think in Recursion 2023 - 2024
      <a href="https://www.linkedin.com/in/windmaomao/">F. Jin</a>
    </p>
  </div>
  <p>
    <a href="#top">Back to top</a>
  </p>
</footer>
 <script type="module" async="">import mermaid from "https://unpkg.com/mermaid@10/dist/mermaid.esm.min.mjs";document.addEventListener('DOMContentLoaded', mermaid.initialize({"loadOnSave":true}));</script>
  </body>
</html>
