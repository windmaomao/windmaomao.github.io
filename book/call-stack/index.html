
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Think in Recursion book by F. Jin, covers recursion problems such as sum, fibonacci, climb stair, bucket fill, permutation and etc." />
    <meta name="keywords" content="Recursion, Javascript, Haskell, Fibonacci, Permutation" />
    <meta name="author" content="Fang Jin" />
    <link rel=icon type=image/png href="../images/favi.png">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap"
      rel="stylesheet"
      type="text/css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,400;0,700;1,300;1,400&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&display=swap"
      rel="stylesheet"
      type="text/css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Rubik:wght@400&display=swap"
      rel="stylesheet"
      type="text/css"
    />
    <link
      href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../bundle.css" />
    <title>Call stack</title>
  </head>
  <body id="top">
    <nav>
  <div class="navbar">
    <div class="container nav-container">
      <input class="checkbox" type="checkbox" name="" id="" />
      <div class="hamburger-lines">
        <span class="line line1"></span>
        <span class="line line2"></span>
        <span class="line line3"></span>
      </div>
      <div class="logo">
        <p><a href="/">Think in Recursion</a></p>
      </div>
      <div class="menu-items"><li>
          <a href="/sum-numbers/"
            >1. Sum</a
          >
        </li><li>
          <a href="/call-stack/"
            >2. Call stack</a
          >
        </li><li>
          <a href="/factorial/"
            >3. Factorial</a
          >
        </li><li>
          <a href="/fib-sequence/"
            >4. Fibonacci</a
          >
        </li><li>
          <a href="/climb-stairs/"
            >5. Climbing stairs</a
          >
        </li><li>
          <a href="/bucket-fill/"
            >6. Flood fill</a
          >
        </li><li>
          <a href="/permutation/"
            >7. Permutation</a
          >
        </li></div>
    </div>
  </div>
</nav>

    <main><p class="chapter-number">2</p>
<h1>Call stack</h1>
<p>From time to time, you might see this error in your console output. Normally this indicates that your code has a bug.</p>
<pre><code>&gt; Maximum call stack size exceeded VM327:2
  sum @ VM327:2
  sum @ VM327:3
  sum @ VM327:3
  sum @ VM327:3
  ...
</code></pre>
<p>But what does it mean? If you drill down the error message, you will discover a lot of lines with similar messages. I thought the debug info should provide us info that helps us debug :)</p>
<p>The debug info actually tells us what happened. Your code calls <code>sum</code>, and then calls <code>sum</code> and then calls <code>sum</code> ... Because we keep calling a function without finishing the previous functions. In the end, it reaches what's called the &quot;Maximum call stack size&quot;.</p>
<h2>What is call stack?</h2>
<p>The call stack, as the name refers to, is a container for calls, function calls. When you call a function, it'll create an item in the call list. Because the computer needs to keep track of how many unfinished calls currently.</p>
<p class="caption"><img src="../images/stack.png" alt="Call stack"><br>
Fig. Call stack</p>
<p>A function serves two important purposes in the context of call stack, one is to allocate the memery space for this call, such as local variables including input arguments. Another one is to know where it returns to after finished. So for each newly added call, it takes several kilobtype of memory. You can think this as the overhead of calling a function. Basically if your code is made with no functions, the overhead cost is kept at minimum.</p>
<p>Now it's making perfect sense that why we can get this error. If you keep adding calls that can't finish before issuing more calls, eventually it'll exceed some memory storage limit. Because otherwise it'll crash your computer, remember the blue screen in the old days. We don't want to get that. Instead, the system just tell us we reach the limit.</p>
<p>There's some ambiguity about the &quot;call stack size&quot;. Most of time it actually doesn't mean the total number of active calls. Since each call's size isn't same, so the most optimal way to define the stack size is the total memory consumption so far for all the active calls. Once the storage limit for call stack is reached, the error is issued.</p>
<p>One thing for sure is that, 99% of time when you get this error, it's due to a coding bug. It's really hard to write a code that generates that many of unfinished calls. Two conditions here: one, lots of calls, like thousands of calls; two, all the calls are not finished. Thus almost the only way to meet these two conditions is, we accidently call a function inside itself, like a recursion.</p>
<p>If it is a bug, we can fix it. But in our recursion code used in the previous chapter, our intention is the recursion. Using <code>sum</code> as an example, we want to be able to sum from <code>0</code> to <code>n</code>, where <code>n</code> can any reasonable integer <code>1,10,100,1000,10000,100000</code> number. However, due to the call stack limit, the maximum number we can go is limited. Depending your language, your machine or even your version number of the compiler, it can vary. On my laptop with <code>node</code>, it's around <code>10000</code>.</p>
<pre><code>&gt; sum(10000)
Maximum call stack size exceeded VM327:2
</code></pre>
<p>So when you increase <code>n</code> and test results, suddenly you'll hit the above error. What's the difference between <code>9999</code> and <code>10000</code>, not much in your code. It's still the same code. Except we can't add more calls.</p>
<p>Bummer!</p>
<p>In order to run code with more recursion level, we need to find a way to walk around this problem. There are couple of options.</p>
<h2>Live with it</h2>
<p>The option sounds not an option.</p>
<p>10000 calls is a lot of active function calls. Luckily, lots of problems can be solved within this limit.</p>
<p>If you really really want to make more calls, there's still ways. Your language running environment provides a way for us to change this limit temporarily. For JavaScript, we can play with the stack-size setting.</p>
<pre><code>&gt; node --stack-size=900 sum.js
Maximum stack size is 12763 calls
</code></pre>
<p>It’s not too bad temporarily, but it can be inconvenient. Also the maximum call stack size is there for a reason; it tries to protect you from the stack overflow.</p>
<p>Other than living with it, we have other ways addressing this issue.</p>
<h2>Iterative setup</h2>
<p>Luckily there’s different ways of implementing the recursion. We have been using recursive function calls. But we can also implement the recursion with the iterative setup. Or sometimes when we finish a recursive, we convert it using an iterative setup.</p>
<p>For example, we could write our <code>sum</code> algorithm in an iterative setup.</p>
<pre><code>function sum(n)
{
  let res = 0;
  for (let i = 0; i &lt;= n; i++) {
    res = res + i
  }
  return res;
}
</code></pre>
<p>I know what you’re gonna say. It’s basically the classical <code>for</code> approach. Well, I admit it, but for this simple problem, it just happens that the converted version is identical to the iterative version. I can call this a coincidence, however it probably isn't an coincidence that both setups point to the same version. In the end, they suppose to do the same thing.</p>
<p>After the conversion, maybe all recursion carries a bit assemblence to the iterative approach. But the matter of fact is that, the recursion nature is kept during the conversion, whereas the iterative approach has no recursion built in mind. And interestingly enough, not all recursion can be converted very easily. Some are easy, and some can be really tricky to write. Therefore I assure you, the iterative approach and the iterative setup for the recursion are two different things.</p>
<p>With the converted version, we can now call it with larger number without worrying about running into error.</p>
<pre><code>&gt; sum(10000)
50005000
&gt; sum(100000)
5000050000
&gt; sum(1000000)
500000500000
&gt; sum(10000000)
50000005000000
&gt; sum(100000000)
5000000050000000
&gt; sum(1000000000)
50000000006710900
</code></pre>
<h2>Haskell language</h2>
<p>In terms of running recursion without hitting the limit, here comes the third option.</p>
<p>Recursion normally isn’t a language feature, it’s more like a by-product of a language. It doesn't get enough attention by the main stream languages usually. However, there exits language that does build on top of the recursion, such as Haskell - an advanced, purely functional programming language.</p>
<p>It’s hard to miss this language if you are fan of recursion, because Haskell fully appreciates the power of recursion at its core. Using it to write recursion is like writing down our thoughts. Say we write the sum in recursion in Haskell.</p>
<pre><code>sum 0 = 0
sum n = sum (n-1) + n
</code></pre>
<p>The syntax of Haskell function is slightly different, it calls the function without the bracket, instead it uses a space to separate the function name and its argument. Our Haskell version for sum has two lines, and looks quite similar to our documentation of the recursion :) Yeah, that's the code.</p>
<p>Run it and let's see the result.</p>
<pre><code>&gt; sum 10000
50005000
&gt; sum 100000
5000050000
&gt; sum 1000000
500000500000
&gt; sum 10000000
50000005000000
&gt; sum 100000000
5000000050000000
&gt; sum 1000000000
500000000500000000
</code></pre>
<p>The Haskell version works with large recursion levels out of the box. And it takes only a few seconds to run. This shows the power of Haskell as well as its dedication to the recursion.</p>
<blockquote>
<p>Have you noticed the sum carries a pattern by magnitude of 10? like 5050, 500500, 50005000, interesting.</p>
</blockquote>
<p>You might be like, if Haskell is that easy, why don’t we just start with Haskell, well, as I mentioned, writing in Haskell is like writing your thoughts, and sometimes it’s difficult to write down your thoughts, it takes some skill and practice. We are not teaching this skill in this book, instead we’ll use Haskell version as a reference to confirm our design and check results, more to use Haskell as a helper.</p>
<blockquote>
<p>Haskell also comes with a call stack limit. The reason why we don't hit it in this case is mainly because Haskell does a tail call optimiasation.</p>
</blockquote>
</main>
    <footer>
  <div>
    <p>
      <a
        href="https://www.freepik.com/free-vector/brain-icons-flat_4663387.htm#query=brain&position=15&from_view=search&track=sph&uuid=c43d2599-7e99-42e3-9d6b-4cc4b554107c?log-in=google"
      >
        Image by macrovector_official</a
      >
      on Freepik
    </p>
    <p>
      © Think in Recursion 2023 - 2024
      <a href="https://www.linkedin.com/in/windmaomao/">F. Jin</a>
    </p>
  </div>
  <p>
    <a href="#top">Back to top</a>
  </p>
</footer>
 <script type="module" async>import mermaid from "https://unpkg.com/mermaid@10/dist/mermaid.esm.min.mjs";document.addEventListener('DOMContentLoaded', mermaid.initialize({"loadOnSave":true}));</script>
  </body>
</html>
