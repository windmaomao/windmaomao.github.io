
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
      href='https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap'
      rel='stylesheet'
      type='text/css'>
    <link
      href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,400;0,700;1,300;1,400&display=swap"
      rel="stylesheet">
    <link
      href='https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&display=swap'
      rel='stylesheet'
      type='text/css'>
    <link href='https://fonts.googleapis.com/css2?family=Rubik:wght@400&display=swap' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../bundle.css">
    <title>Sum numbers</title>
  </head>
  <body id="top">
    <nav>
  <div class="navbar">
    <div class="container nav-container">
      <input class="checkbox" type="checkbox" name="" id=""/>
      <div class="hamburger-lines">
        <span class="line line1"></span>
        <span class="line line2"></span>
        <span class="line line3"></span>
      </div>
      <div class="logo">
        <p>Think in Recursion</p>
        <p><img src='../images/logo.png'/></p>
      </div>
      <div class="menu-items"><li><a href="/recursion-limit/">2. Recursion limit</a></li><li><a href="/fib-sequence/">3. Fibonacci sequence</a></li><li><a href="/sum-numbers/">1. Sum numbers</a></li></div>
    </div>
  </div>
</nav>
    <main>
      <p class="chapter-number">1</p>
<h1>Sum numbers</h1>
<blockquote>
<p>There’s no easier way to start doing something than doing it.</p>
</blockquote>
<p><img src="../images/sum.png" alt="Sum numbers"></p>
<p>What is a recursion within an algorithm?</p>
<h2>Sum numbers</h2>
<blockquote>
<p>Tom: &quot;Miss Sophia want us to sum from 0 to 5&quot;<br>
Me: &quot;Oh yeah, let's do it then. 0 + 1 = 1; 1 + 2 = 3; ...&quot;<br>
Tom: &quot;Wait, wait, i know the sum from 0 to 4, which is 10. I remember it.&quot;<br>
Me: &quot;Okey, in that case, the answer is 15 then!&quot;</p>
</blockquote>
<p>Say we want to find out the sum of a list of number from <code>0</code> to <code>n</code>. Assuming we have known the sum to the previous number <code>n-1</code> , we can start with a simple algorithm.</p>
<pre class="javascript">function sum(n) {
  return m + n;
}
</pre>
<p>What is <code>m</code> ?</p>
<blockquote>
<p>Me: &quot;Did you forget something? what is m?&quot;<br>
Tom: &quot;oh, I forgot. m equals to sum(n - 1)!&quot;<br>
Me: &quot;What?&quot;<br>
Tom: &quot;What's the matter?&quot;<br>
Me: &quot;... Nothing.&quot;</p>
</blockquote>
<p>Replacing <code>m</code> with <code>sum(n-1)</code>, like someone knew <code>sum(n-1)</code> already.</p>
<pre class="javascript">function sum(n) {
  return sum(n - 1) + n;
}
</pre>
<blockquote>
<p>Me: &quot;I don't really think this would work. &quot;<br>
Tom: &quot;Why not? If I know sum(4), then I can tell you sum(5).&quot;<br>
Me: &quot;But what is sum(4)? How could you know sum(4) first.&quot;<br>
Tom: &quot;Well, if you can tell me what is sum(3) first.&quot;<br>
Me: &quot;This is ridiculous; how am I supposed to tell you sum(3)?&quot;<br>
Tom: &quot;That's true, but I think I know what is sum(0)&quot;.<br>
Me &amp; Tom: &quot;That is zero!&quot;<br>
Tom: &quot;Ok, if we know sum(0), then I know sum(1) and ...&quot;<br>
Me &amp; Tom: &quot;Then I know sum(5).&quot;</p>
</blockquote>
<p>What we are missing is a case for 0, let’s add it.</p>
<pre class="javascript">function sum(n) {
  if (n == 0) return 0;
  return sum(n - 1) + n;
}
</pre>
<p>We can’t wait to run it.</p>
<pre class="javascript">> count(5)
15
</pre>
<p>It's <code>15</code>, that's just great!</p>
<blockquote>
<p>Me: &quot;To be honest, I didn't expect we can get the result this way.&quot;<br>
Tom: &quot;Me either, but let's give it a name, we might make some fortune.&quot;<br>
Me &amp; Tom: &quot;Recursion?!&quot;</p>
</blockquote>
<p>This is a recursion.</p>
<h2>Recursion with function instance</h2>
<p>What is the sum function?</p>
<pre class="javascript">function sum(n) {
  if (n == 0) return 0;
  return sum(n - 1) + n;
}
</pre>
<p>Inside the sum function, it calls the sum function. So it calls itself.</p>
<p>It sort looks like that. There’s also an argument associated with each function call, like sum(n) and sum(n-1). If we use the argument instead, we could distinguish both sum, since the former is called n and the latter is called n-1. In fact, this is exactly how it works, both are called function instance, they are the instances of the same function sum.</p>
<p>What is the difference between each function instance, say between sum(n) and sum(n-1)? It’s subtle. At one hand, they follow the same logic from the shared function body. But on another hand, each can have slight variations due to the exact pathway a function instance take. In our sum case, sum(5) is quite similar to sum(4), but not with sum(0); because the function instance with 0 as argument will return 0 right away. You can think sum(0) as a instance boundary, when the code reaches there, it has to go back to where it was called.</p>
<p>Since a function’s job is to run through some calculations and return the result, all function instances need to return sooner or later. Since it takes time to call and finish a function call, a function instance can be called but not yet finished. This function instance is then referred as an active instance. For example, after we call sum(5), it calls sum(4), when sum(4) is getting called, sum(5) hasn’t finished yet, thus sum(5) has to be active.</p>
<p>Alright, we have gone through couple of the key elements of a typical recursion, the function instance. We’ll come back to it often throughout this book. For each recursion problem we encounter, we’ll design the instance logic before we write the code.</p>
<h2>New way of looking at the recursion</h2>
<p>One of the challenge of learning recursion is that we are very used to the classical way of doing things using a <em>for</em> loop. But with recursion, things seem to be quite wild. In my opinion, this has something to do with the way we analyze the recursion.</p>
<p>If I tell you that you have been trained to be linear when it comes to the computer programming, what do you think? Why don’t we take it from a different angle?</p>
<blockquote>
<p>Tom: “We should read the sum function line by line.”<br>
Me: “Isn’t this what we just did, line by line?”<br>
Tom: “No, I didn’t mean by the compiler. I mean by us.”<br>
Me: “I’m confused, what you mean?”<br>
Tom: “Just read it line by line and do it once.”</p>
</blockquote>
<p>Let’s take a look at the function once again and see if this time we can just go over once.</p>
<pre class="">function sum(n) {
if (n == 0) return 0
return sum(n - 1) + n
}
</pre>
<p>Say we start at one function instance n. What does the instance do after we call it?</p>
<pre class="">sum(n) -> sum(n - 1) + n
sum(0) -> 0
</pre>
<p>It asks us to call sum(n-1). This time, we do things a bit differently. Say we rename sum(n-1) to abc(n-1) for a second. The function abc returns the sum from 0 to n-1. Then we take the number returned from abc, add n to it and return it. That’s it. This is when n is not 0.</p>
<p>When n is 0, sum(0) returns 0 right away. That’s it.</p>
<p>Now let’s organize our thoughts a bit. So far, do you like this new way of tracing the recursive process only once?</p>
<blockquote>
<p>Tom: “How do you feel?”<br>
Me: “I don’t know. Aren’t they same?”<br>
Tom: “Have you gone through each instance?”<br>
Me: “Not really, I felt I went through the function once. But I also felt that I did nothing.”<br>
Tom: “Weird! Isn’t it?”</p>
</blockquote>
<p>To be frank, I don’t really know whether this should be called the new way of looking at the recursion, because literally what we did is to go through the logic of the function body once. But why do we emphasize this way of reasoning?</p>
<p>Couple of reasons. One as you have seen, it’s sticking to the implementation precisely. Or you can say the implementation should be sticking with the reasoning first. Two, a function can have multiple instances, but more or less it should do the same thing, therefore in theory we should just go through it once, and done with it.</p>
<p>Anybody’s brain, no matter how hard they have it trained in the past, has a limit. For instance, when I ask you to sum 0 to 5, you can go through all cases one by one taking your time; now if I raise n to 23, you might start to hesitate to spend time digging into each cases; now if I raise it to 178. You’d give up already. Not to mention n can be 348932483. The point is that, for the same problem, we can get different response simply by changing the size of the problem.</p>
<p>In order to study the problem effectively, we shouldn’t let it happen though.</p>
<p>Going through the recursion only once can be very effective, since it’s independent to the problem size. Strange enough, no matter how big the size, we are looking at the same function body. This also makes the running time analysis of the recursion possible.</p>
<h2>Running time of recursion</h2>
<p>The running time of an algorithm provides the order of the speed of the code, and is expressed as an expression. The notation is the big O. The number <code>n</code> is the size of the problem.</p>
<p>The running time O isn’t a precise measurement. It can’t tell you exactly how much time your algorithm spends. You still need to run the code to find out the exact number. But it can tell you the relationship between the running time and the size. For example, O(1) means the running time is a constant independent to n. O(n) is said to be linear with n.</p>
<p><img src="../images/stairs.png" alt="Running time for more terms"></p>
<p>What’s the running time for our sum algorithm? We can figure that out by looking at the function body.</p>
<pre class="">sum(n)
  --> calls sum(n-1) and stores in a
  --> adds a and n, and returns it
</pre>
<p>For each function call, it calls another one and stores in a temperary variable, call it <code>a</code>, and then adds <code>a</code> and <code>n</code> together. Say the time spent for <code>sum(n)</code> is <code>t|n</code>, meaning <code>t</code> at <code>n</code>.</p>
<pre class="">t|n = t|n-1 + 1
</pre>
<p>Then the time spent at <code>n</code> is the time spent at <code>n-1</code> plus one. One stands for the unit time spent for the addition operation. I believe we can figure out that the time spent for <code>n</code> is actually <code>n</code> now.</p>
<p>Imaginging you are climbing stairs, the time it takes to climb one stair is one unit time. Thus the total time spent on climbing to this stair equals to the total time spent to the previous stair plus one.</p>
<pre class="">t|n = n = O(n)
</pre>
<p>Thus the running time of our algorithm is said to be <code>O(n)</code>, meaning the running time is linearly proportional to <code>n</code>. If sum(1) takes 1 microsecond, then we expect sum(5) to take about 5 microseconds. Of course 5 microseconds isn’t an accurate measurement, but we don’t expect to get sum(5) taking more than 10 microseconds, because that would break the O(n) analysis.</p>
<blockquote>
<p>Recursion is one way of programming. Which means everything you learned from computer science still applies.</p>
</blockquote>
<p>We can take a look at some typical running time order in the following graph.</p>
<p><img src="../images/time.png" alt="Running time"></p>
<p class="caption">Fig. Runing time order comparison</p>
<p><code>O(1)</code> is an ideal one, which is a contant and extremely fast. O(log(n)), and O(n) are relatively efficient. Going to the left, O(nlogn) and O(n^2) start to be relatively more expensive. To the very left, O(2<sup>n</sup>) is an expensive algorithm and O(n!) is extremely expensive, and it explods even in small n. In general, we want to aim for more efficient algorithm design and avoid to land on very expensive one.</p>

    </main>
    <footer>
  <div>
    <p>
      <a
        href="https://www.freepik.com/free-vector/brain-icons-flat_4663387.htm#query=brain&position=15&from_view=search&track=sph&uuid=c43d2599-7e99-42e3-9d6b-4cc4b554107c?log-in=google"
      >
        Image by macrovector_official</a
      >
      on Freepik
    </p>
    <p>
      © Think in Recursion 2023 - 2024
      <a href="https://www.linkedin.com/in/windmaomao/">F. Jin</a>
    </p>
  </div>
  <p>
    <a href="#top">Back to top</a>
  </p>
</footer>

    <script type="module" async>import mermaid from "https://unpkg.com/mermaid@10/dist/mermaid.esm.min.mjs";document.addEventListener('DOMContentLoaded', mermaid.initialize({startOnLoad:true}));</script>
  </body>
</html>